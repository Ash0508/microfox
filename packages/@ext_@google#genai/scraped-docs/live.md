{
  "url": "https://ai.google.dev/gemini-api/docs/live",
  "content": "Skip to main content\nSign in\nModels\nMore\nGemini API docs\nAPI Reference\nCookbook\nCommunity\nSolutions\nMore\nCode assistance\nMore\nShowcase\nMore\nCommunity\nMore\nGet started\nOverview\nQuickstart\nAPI keys\nLibraries\nOpenAI compatibility\nModels\nAll models\nPricing\nRate limits\nBilling info\nModel Capabilities\nText generation\nImage generation\nVideo generation\nLong context\nStructured output\nThinking\nFunction calling\nDocument understanding\nImage understanding\nVideo understanding\nAudio understanding\nCode execution\nGrounding with Google Search\nGuides\nPrompt engineering\nLive API\nContext caching\nFiles API\nToken counting\nFine-tuning\nEmbeddings\nSafety\nResources\nMigrate to Gen AI SDK\nRelease notes\nAPI troubleshooting\nAI Studio\nCloud\nPolicies\nTerms of service\nAvailable regions\nAdditional usage polices\nIntroducing Gemini 2.5 Flash, Veo 2, and updates to the Live API Learn more\nHome\nGemini API\nModels\nWas this helpful?\nSend feedback\nLive API\nOn this page\nWhat's new\nUse the Live API\nSend and receive text\nReceive audio\nStream audio and video\nSystem instructions\nIncremental content updates\nChange voices\n\nPreview: The Live API is in preview.\n\nThe Live API enables low-latency bidirectional voice and video interactions with Gemini. Using the Live API, you can provide end users with the experience of natural, human-like voice conversations, and with the ability to interrupt the model's responses using voice commands. The model can process text, audio, and video input, and it can provide text and audio output.\n\nYou can try the Live API in Google AI Studio.\n\nTo try a tutorial that lets you use your voice and camera to talk to Gemini through the Live API, see the Web Console Demo project.\nWhat's new\n\nCheck out the Changelog for the latest new features and capabilities in the Live API!\n\nUse the Live API\n\nThis section describes how to use the Live API with one of our SDKs. For more information about the underlying WebSockets API, see the WebSockets API reference.\n\nTo use all features, make sure to install the latest SDK version, e.g., pip install -U google-genai.\n\nNote: You can only set one modality in the response_modalities field. This means that you can configure the model to respond with either text or audio, but not both in the same session.\nSend and receive text\nimport asyncio\nfrom google import genai\n\nclient = genai.Client(api_key=\"GEMINI_API_KEY\")\nmodel = \"gemini-2.0-flash-live-001\"\n\nconfig = {\"response_modalities\": [\"TEXT\"]}\n\nasync def main():\n    async with client.aio.live.connect(model=model, config=config) as session:\n        while True:\n            message = input(\"User> \")\n            if message.lower() == \"exit\":\n                break\n            await session.send_client_content(\n                turns={\"role\": \"user\", \"parts\": [{\"text\": message}]}, turn_complete=True\n            )\n\n            async for response in session.receive():\n                if response.text is not None:\n                    print(response.text, end=\"\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n\nReceive audio\n\nThe following example shows how to receive audio data and write it to a .wav file.\n\nimport asyncio\nimport wave\nfrom google import genai\n\nclient = genai.Client(api_key=\"GEMINI_API_KEY\")\nmodel = \"gemini-2.0-flash-live-001\"\n\nconfig = {\"response_modalities\": [\"AUDIO\"]}\n\nasync def main():\n    async with client.aio.live.connect(model=model, config=config) as session:\n        wf = wave.open(\"audio.wav\", \"wb\")\n        wf.setnchannels(1)\n        wf.setsampwidth(2)\n        wf.setframerate(24000)\n\n        message = \"Hello? Gemini are you there?\"\n        await session.send_client_content(\n            turns={\"role\": \"user\", \"parts\": [{\"text\": message}]}, turn_complete=True\n        )\n\n        async for idx,response in async_enumerate(session.receive()):\n            if response.data is not None:\n                wf.writeframes(response.data)\n\n            # Un-comment this code to print audio data info\n            # if response.server_content.model_turn is not None:\n            #      print(response.server_content.model_turn.parts[0].inline_data.mime_type)\n\n        wf.close()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n\nAudio formats\n\nAudio data in the Live API is always raw, little-endian, 16-bit PCM. Audio output always uses a sample rate of 24kHz. Input audio is natively 16kHz, but the Live API will resample if needed so any sample rate can be sent. To convey the sample rate of input audio, set the MIME type of each audio-containing Blob to a value like audio/pcm;rate=16000.\n\nStream audio and video\n\nTo see an example of how to use the Live API in a streaming audio and video format, run the \"Live API - Quickstart\" file in the cookbooks repository:\n\nView on GitHub\n\nSystem instructions\n\nSystem instructions let you steer the behavior of a model based on your specific needs and use cases. System instructions can be set in the setup configuration and will remain in effect for the entire session.\n\nfrom google.genai import types\n\nconfig = {\n    \"system_instruction\": types.Content(\n        parts=[\n            types.Part(\n                text=\"You are a helpful assistant and answer in a friendly tone.\"\n            )\n        ]\n    ),\n    \"response_modalities\": [\"TEXT\"],\n}\n\nIncremental content updates\n\nUse incremental updates to send text input, establish session context, or restore session context. For short contexts you can send turn-by-turn interactions to represent the exact sequence of events:\n\nPython\nJSON\nturns = [\n    {\"role\": \"user\", \"parts\": [{\"text\": \"What is the capital of France?\"}]},\n    {\"role\": \"model\", \"parts\": [{\"text\": \"Paris\"}]},\n]\n\nawait session.send_client_content(turns=turns, turn_complete=False)\n\nturns = [{\"role\": \"user\", \"parts\": [{\"text\": \"What is the capital of Germany?\"}]}]\n\nawait session.send_client_content(turns=turns, turn_complete=True)\n\n\nFor longer contexts it's recommended to provide a single message summary to free up the context window for subsequent interactions.\n\nChange voices\n\nThe Live API supports the following voices: Puck, Charon, Kore, Fenrir, Aoede, Leda, Orus, and Zephyr.\n\nTo specify a voice, set the voice name within the speechConfig object as part of the session configuration:\n\nPython\nJSON\nfrom google.genai import types\n\nconfig = types.LiveConnectConfig(\n    response_modalities=[\"AUDIO\"],\n    speech_config=types.SpeechConfig(\n        voice_config=types.VoiceConfig(\n            prebuilt_voice_config=types.PrebuiltVoiceConfig(voice_name=\"Kore\")\n        )\n    )\n)\n\nChange language\n\nThe Live API supports multiple languages.\n\nTo change the language, set the language code within the speechConfig object as part of the session configuration:\n\nfrom google.genai import types\n\nconfig = types.LiveConnectConfig(\n    response_modalities=[\"AUDIO\"],\n    speech_config=types.SpeechConfig(\n        language_code=\"de-DE\",\n    )\n)\n\nUse tools\n\nYou can define tools such as Function calling, Code execution, and Google Search with the Live API.\n\nTo see examples of all tools in the Live API, run the \"Live API Tools\" cookbook:\n\nView on GitHub\n\nUse function calling\n\nYou can define function declarations as part of the session configuration. See the Function calling tutorial to learn more.\n\nAfter receiving tool calls, the client should respond with a list of FunctionResponse objects using the session.send_tool_response method.\n\nNote: Unlike the generateContent API, the Live API doesn't support automatic tool response handling. You must handle tool responses manually in your client code.\nimport asyncio\nfrom google import genai\nfrom google.genai import types\n\nclient = genai.Client(api_key=\"GEMINI_API_KEY\")\nmodel = \"gemini-2.0-flash-live-001\"\n\n# Simple function definitions\nturn_on_the_lights = {\"name\": \"turn_on_the_lights\"}\nturn_off_the_lights = {\"name\": \"turn_off_the_lights\"}\n\ntools = [{\"function_declarations\": [turn_on_the_lights, turn_off_the_lights]}]\nconfig = {\"response_modalities\": [\"TEXT\"], \"tools\": tools}\n\nasync def main():\n    async with client.aio.live.connect(model=model, config=config) as session:\n        prompt = \"Turn on the lights please\"\n        await session.send_client_content(turns={\"parts\": [{\"text\": prompt}]})\n\n        async for chunk in session.receive():\n            if chunk.server_content:\n                if chunk.text is not None:\n                    print(chunk.text)\n            elif chunk.tool_call:\n                function_responses = []\n                for fc in tool_call.function_calls:\n                    function_response = types.FunctionResponse(\n                        id=fc.id,\n                        name=fc.name,\n                        response={ \"result\": \"ok\" } # simple, hard-coded function response\n                    )\n                    function_responses.append(function_response)\n\n                await session.send_tool_response(function_responses=function_responses)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n\n\nFrom a single prompt, the model can generate multiple function calls and the code necessary to chain their outputs. This code executes in a sandbox environment, generating subsequent BidiGenerateContentToolCall messages. The execution pauses until the results of each function call are available, which ensures sequential processing.\n\nAudio inputs and audio outputs negatively impact the model's ability to use function calling.\n\nUse Code execution\n\nYou can define code execution as part of the session configuration. See the Code execution tutorial to learn more.\n\nimport asyncio\nfrom google import genai\nfrom google.genai import types\n\nclient = genai.Client(api_key=\"GEMINI_API_KEY\")\nmodel = \"gemini-2.0-flash-live-001\"\n\ntools = [{'code_execution': {}}]\nconfig = {\"response_modalities\": [\"TEXT\"], \"tools\": tools}\n\nasync def main():\n    async with client.aio.live.connect(model=model, config=config) as session:\n        prompt = \"Compute the largest prime palindrome under 100000.\"\n        await session.send_client_content(turns={\"parts\": [{\"text\": prompt}]})\n\n        async for chunk in session.receive():\n            if chunk.server_content:\n                if chunk.text is not None:\n                    print(chunk.text)\n            \n                model_turn = chunk.server_content.model_turn\n                if model_turn:\n                    for part in model_turn.parts:\n                      if part.executable_code is not None:\n                        print(part.executable_code.code)\n\n                      if part.code_execution_result is not None:\n                        print(part.code_execution_result.output)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n\nUse Grounding with Google Search\n\nYou can enable Grounding with Google Search as part of the session configuration. See the Grounding tutorial to learn more.\n\nimport asyncio\nfrom google import genai\nfrom google.genai import types\n\nclient = genai.Client(api_key=\"GEMINI_API_KEY\")\nmodel = \"gemini-2.0-flash-live-001\"\n\ntools = [{'google_search': {}}]\nconfig = {\"response_modalities\": [\"TEXT\"], \"tools\": tools}\n\nasync def main():\n    async with client.aio.live.connect(model=model, config=config) as session:\n        prompt = \"When did the last Brazil vs. Argentina soccer match happen?\"\n        await session.send_client_content(turns={\"parts\": [{\"text\": prompt}]})\n\n        async for chunk in session.receive():\n            if chunk.server_content:\n                if chunk.text is not None:\n                    print(chunk.text)\n\n                # The model might generate and execute Python code to use Search\n                model_turn = chunk.server_content.model_turn\n                if model_turn:\n                    for part in model_turn.parts:\n                      if part.executable_code is not None:\n                        print(part.executable_code.code)\n\n                      if part.code_execution_result is not None:\n                        print(part.code_execution_result.output)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n\nCombine multiple tools\n\nYou can combine multiple tools within the Live API:\n\nprompt = \"\"\"\nHey, I need you to do three things for me.\n\n1. Compute the largest prime palindrome under 100000.\n2. Then use Google Search to look up information about the largest earthquake in California the week of Dec 5 2024?\n3. Turn on the lights\n\nThanks!\n\"\"\"\n\ntools = [\n    {\"google_search\": {}},\n    {\"code_execution\": {}},\n    {\"function_declarations\": [turn_on_the_lights, turn_off_the_lights]},\n]\n\nconfig = {\"response_modalities\": [\"TEXT\"], \"tools\": tools}\n\nHandle interruptions\n\nUsers can interrupt the model's output at any time. When Voice activity detection (VAD) detects an interruption, the ongoing generation is canceled and discarded. Only the information already sent to the client is retained in the session history. The server then sends a BidiGenerateContentServerContent message to report the interruption.\n\nIn addition, the Gemini server discards any pending function calls and sends a BidiGenerateContentServerContent message with the IDs of the canceled calls.\n\nasync for response in session.receive():\n    if response.server_content.interrupted is True:\n        # The generation was interrupted\n\nConfigure voice activity detection (VAD)\n\nYou can configure or disable voice activity detection (VAD).\n\nUse automatic VAD\n\nBy default, the model automatically performs VAD on a continuous audio input stream. VAD can be configured with the realtimeInputConfig.automaticActivityDetection field of the setup configuration.\n\nWhen the audio stream is paused for more than a second (for example, because the user switched off the microphone), an audioStreamEnd event should be sent to flush any cached audio. The client can resume sending audio data at any time.\n\n# example audio file to try:\n# URL = \"https://storage.googleapis.com/generativeai-downloads/data/hello_are_you_there.pcm\"\n# !wget -q $URL -O sample.pcm\nimport asyncio\nfrom pathlib import Path\nfrom google import genai\n\nclient = genai.Client(api_key=\"GEMINI_API_KEY\")\nmodel = \"gemini-2.0-flash-live-001\"\n\nconfig = {\"response_modalities\": [\"TEXT\"]}\n\nasync def main():\n    async with client.aio.live.connect(model=model, config=config) as session:\n        audio_bytes = Path(\"sample.pcm\").read_bytes()\n\n        await session.send_realtime_input(\n            audio=types.Blob(data=audio_bytes, mime_type=\"audio/pcm;rate=16000\")\n        )\n\n        # if stream gets paused, send:\n        # await session.send_realtime_input(audio_stream_end=True)\n\n        async for response in session.receive():\n            if response.text is not None:\n                print(response.text)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n\n\nWith send_realtime_input, the API will respond to audio automatically based on VAD. While send_client_content adds messages to the model context in order, send_realtime_input is optimized for responsiveness at the expense of deterministic ordering.\n\nConfigure automatic VAD\n\nFor more control over the VAD activity, you can configure the following parameters. See API reference for more info.\n\nfrom google.genai import types\n\nconfig = {\n    \"response_modalities\": [\"TEXT\"],\n    \"realtime_input_config\": {\n        \"automatic_activity_detection\": {\n            \"disabled\": False, # default\n            \"start_of_speech_sensitivity\": types.StartSensitivity.START_SENSITIVITY_LOW,\n            \"end_of_speech_sensitivity\": types.EndSensitivity.END_SENSITIVITY_LOW,\n            \"prefix_padding_ms\": 20,\n            \"silence_duration_ms\": 100,\n        }\n    }\n}\n\nDisable automatic VAD\n\nAlternatively, the automatic VAD can be disabled by setting realtimeInputConfig.automaticActivityDetection.disabled to true in the setup message. In this configuration the client is responsible for detecting user speech and sending activityStart and activityEnd messages at the appropriate times. An audioStreamEnd isn't sent in this configuration. Instead, any interruption of the stream is marked by an activityEnd message.\n\nconfig = {\n    \"response_modalities\": [\"TEXT\"],\n    \"realtime_input_config\": {\"automatic_activity_detection\": {\"disabled\": True}},\n}\n\nasync with client.aio.live.connect(model=model, config=config) as session:\n    # ...\n    await session.send_realtime_input(activity_start=types.ActivityStart())\n    await session.send_realtime_input(\n        audio=types.Blob(data=audio_bytes, mime_type=\"audio/pcm;rate=16000\")\n    )\n    await session.send_realtime_input(activity_end=types.ActivityEnd())\n    # ...\n\nGet the token count\n\nYou can find the total number of consumed tokens in the usageMetadata field of the returned server message.\n\nasync for message in session.receive():\n    # The server will periodically send messages that include UsageMetadata.\n    if message.usage_metadata:\n        usage = message.usage_metadata\n        print(\n            f\"Used {usage.total_token_count} tokens in total. Response token breakdown:\"\n        )\n        for detail in usage.response_tokens_details:\n            match detail:\n                case types.ModalityTokenCount(modality=modality, token_count=count):\n                    print(f\"{modality}: {count}\")\n\nExtend the session duration\n\nThe maximum session duration can be extended to unlimited with two mechanisms:\n\nEnable context window compression\nConfigure session resumption\n\nFurthermore, you'll receive a GoAway message before the session ends, allowing you to take further actions.\n\nEnable context window compression\n\nTo enable longer sessions, and avoid abrupt connection termination, you can enable context window compression by setting the contextWindowCompression field as part of the session configuration.\n\nIn the ContextWindowCompressionConfig, you can configure a sliding-window mechanism and the number of tokens that triggers compression.\n\nfrom google.genai import types\n\nconfig = types.LiveConnectConfig(\n    response_modalities=[\"AUDIO\"],\n    context_window_compression=(\n        # Configures compression with default parameters.\n        types.ContextWindowCompressionConfig(\n            sliding_window=types.SlidingWindow(),\n        )\n    ),\n)\n\nConfigure session resumption\n\nTo prevent session termination when the server periodically resets the WebSocket connection, configure the sessionResumption field within the setup configuration.\n\nPassing this configuration causes the server to send SessionResumptionUpdate messages, which can be used to resume the session by passing the last resumption token as the SessionResumptionConfig.handle of the subsequent connection.\n\nimport asyncio\nfrom google import genai\nfrom google.genai import types\n\nclient = genai.Client(api_key=\"GEMINI_API_KEY\")\nmodel = \"gemini-2.0-flash-live-001\"\n\nasync def main():\n    print(f\"Connecting to the service with handle {previous_session_handle}...\")\n    async with client.aio.live.connect(\n        model=model,\n        config=types.LiveConnectConfig(\n            response_modalities=[\"AUDIO\"],\n            session_resumption=types.SessionResumptionConfig(\n                # The handle of the session to resume is passed here,\n                # or else None to start a new session.\n                handle=previous_session_handle\n            ),\n        ),\n    ) as session:\n        while True:\n            await session.send_client_content(\n                turns=types.Content(\n                    role=\"user\", parts=[types.Part(text=\"Hello world!\")]\n                )\n            )\n            async for message in session.receive():\n                # Periodically, the server will send update messages that may\n                # contain a handle for the current state of the session.\n                if message.session_resumption_update:\n                    update = message.session_resumption_update\n                    if update.resumable and update.new_handle:\n                        # The handle should be retained and linked to the session.\n                        return update.new_handle\n\n                # For the purposes of this example, placeholder input is continually fed\n                # to the model. In non-sample code, the model inputs would come from\n                # the user.\n                if message.server_content and message.server_content.turn_complete:\n                    break\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n\nReceive a message before the session disconnects\n\nThe server sends a GoAway message that signals that the current connection will soon be terminated. This message includes the timeLeft, indicating the remaining time and lets you take further action before the connection will be terminated as ABORTED.\n\nasync for response in session.receive():\n    if response.go_away is not None:\n        # The connection will soon be terminated\n        print(response.go_away.time_left)\n\nReceive a message when the generation is complete\n\nThe server sends a generationComplete message that signals that the model finished generating the response.\n\nasync for response in session.receive():\n    if response.server_content.generation_complete is True:\n        # The generation is complete\n\nChange the media resolution\n\nYou can specify the media resolution for the input media by setting the mediaResolution field as part of the session configuration:\n\nfrom google.genai import types\n\nconfig = types.LiveConnectConfig(\n    response_modalities=[\"AUDIO\"],\n    media_resolution=types.MediaResolution.MEDIA_RESOLUTION_LOW,\n)\n\nReceive audio transcriptions\n\nYou can enable transcription of the model's audio output. The transcription language is inferred from the model's response.\n\nimport asyncio\nfrom google import genai\nfrom google.genai import types\n\nclient = genai.Client(api_key=\"GEMINI_API_KEY\")\nmodel = \"gemini-2.0-flash-live-001\"\n\nconfig = {\"response_modalities\": [\"AUDIO\"],\n          \"output_audio_transcription\": {}\n}\n\nasync def main():\n    async with client.aio.live.connect(model=model, config=config) as session:\n        message = \"Hello? Gemini are you there?\"\n\n        await session.send_client_content(\n            turns={\"role\": \"user\", \"parts\": [{\"text\": message}]}, turn_complete=True\n        )\n\n        async for response in session.receive():\n            if response.server_content.model_turn:\n                print(\"Model turn:\", response.server_content.model_turn)\n            if response.server_content.output_transcription:\n                print(\"Transcript:\", response.server_content.output_transcription.text)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n\n\nYou can enable transcription of the audio input by sending input_audio_transcription in setup config.\n\nimport asyncio\nfrom google import genai\nfrom google.genai import types\n\nclient = genai.Client(api_key=\"GEMINI_API_KEY\")\nmodel = \"gemini-2.0-flash-live-001\"\n\nconfig = {\"response_modalities\": [\"TEXT\"],\n    \"realtime_input_config\": {\n        \"automatic_activity_detection\": {\"disabled\": True},\n        \"activity_handling\": \"NO_INTERRUPTION\",\n    },\n    \"input_audio_transcription\": {},\n}\n\nasync def main():\n    async with client.aio.live.connect(model=model, config=config) as session:\n        audio_data = Path(\"sample.pcm\").read_bytes()\n\n        await session.send_realtime_input(activity_start=types.ActivityStart())\n        await session.send_realtime_input(\n            audio=types.Blob(data=audio_data, mime_type='audio/pcm;rate=16000')\n        )\n        await session.send_realtime_input(activity_end=types.ActivityEnd())\n\n        async for msg in session.receive():\n            if msg.server_content.input_transcription:\n                print('Transcript:', msg.server_content.input_transcription.text)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n\nLimitations\n\nConsider the following limitations of the Live API and Gemini 2.0 when you plan your project.\n\nResponse modalities\n\nYou can only set one response modality (TEXT or AUDIO) per session in the session configuration. Trying to set both will result in a config error message. This means that you can configure the model to respond with either text or audio, but not both in the same session.\n\nClient authentication\n\nThe Live API only provides server to server authentication and isn't recommended for direct client use. Client input should be routed through an intermediate application server for secure authentication with the Live API.\n\nSession duration\n\nSession duration can be extended to unlimited by enabling session compression. Without compression, audio-only sessions are limited to 15 minutes, and audio plus video sessions are limited to 2 minutes. Exceeding these limits without compression will terminate the connection.\n\nAdditionally, you can configure session resumption to allow the client to resume a session that was terminated.\n\nContext window\n\nA session has a context window limit of 32k tokens.\n\nSupported languages\n\nLive API supports the following languages:\n\nLanguage\tBCP-47 Code\nGerman (Germany)\tde-DE\nEnglish (Australia)\ten-AU\nEnglish (United Kingdom)\ten-GB\nEnglish (India)\ten-IN\nEnglish (US)\ten-US\nSpanish (United States)\tes-US\nFrench (France)\tfr-FR\nHindi (India)\thi-IN\nPortuguese (Brazil)\tpt-BR\nArabic (Generic)\tar-XA\nSpanish (Spain)\tes-ES\nFrench (Canada)\tfr-CA\nIndonesian (Indonesia)\tid-ID\nItalian (Italy)\tit-IT\nJapanese (Japan)\tja-JP\nTurkish (Turkey)\ttr-TR\nVietnamese (Vietnam)\tvi-VN\nBengali (India)\tbn-IN\nGujarati (India)\tgu-IN\nKannada (India)\tkn-IN\nMalayalam (India)\tml-IN\nMarathi (India)\tmr-IN\nTamil (India)\tta-IN\nTelugu (India)\tte-IN\nDutch (Netherlands)\tnl-NL\nKorean (South Korea)\tko-KR\nMandarin Chinese (China)\tcmn-CN\nPolish (Poland)\tpl-PL\nRussian (Russia)\tru-RU\nThai (Thailand)\tth-TH\nThird-party integrations\n\nFor web and mobile app deployments, you can explore options from:\n\nDaily\nLivekit\nWas this helpful?\nSend feedback\n\nExcept as otherwise noted, the content of this page is licensed under the Creative Commons Attribution 4.0 License, and code samples are licensed under the Apache 2.0 License. For details, see the Google Developers Site Policies. Java is a registered trademark of Oracle and/or its affiliates.\n\nLast updated 2025-05-12 UTC.\n\nTerms\nPrivacy",
  "updatedAt": "2025-05-13T03:18:25.206Z"
}