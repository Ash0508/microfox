{
  "url": "https://ai.google.dev/gemini-api/docs/structured-output",
  "content": "Skip to main content\nSign in\nModels\nMore\nGemini API docs\nAPI Reference\nCookbook\nCommunity\nSolutions\nMore\nCode assistance\nMore\nShowcase\nMore\nCommunity\nMore\nGet started\nOverview\nQuickstart\nAPI keys\nLibraries\nOpenAI compatibility\nModels\nAll models\nPricing\nRate limits\nBilling info\nModel Capabilities\nText generation\nImage generation\nVideo generation\nLong context\nStructured output\nThinking\nFunction calling\nDocument understanding\nImage understanding\nVideo understanding\nAudio understanding\nCode execution\nGrounding with Google Search\nGuides\nPrompt engineering\nLive API\nContext caching\nFiles API\nToken counting\nFine-tuning\nEmbeddings\nSafety\nResources\nMigrate to Gen AI SDK\nRelease notes\nAPI troubleshooting\nAI Studio\nCloud\nPolicies\nTerms of service\nAvailable regions\nAdditional usage polices\nIntroducing Gemini 2.5 Flash, Veo 2, and updates to the Live API Learn more\nHome\nGemini API\nModels\nSend feedback\nStructured output\nOn this page\nGenerating JSON\nConfiguring a schema (recommended)\nProviding a schema in a text prompt\nGenerating enum values\nAbout JSON schemas\nProperty ordering\nSchemas in Python\nBest practices\n\nYou can configure Gemini for structured output instead of unstructured text, allowing precise extraction and standardization of information for further processing. For example, you can use structured output to extract information from resumes, standardize them to build a structured database.\n\nGemini can generate either JSON or enum values as structured output.\n\nGenerating JSON\n\nThere are two ways to generate JSON using the Gemini API:\n\nConfigure a schema on the model\nProvide a schema in a text prompt\n\nConfiguring a schema on the model is the recommended way to generate JSON, because it constrains the model to output JSON.\n\nConfiguring a schema (recommended)\n\nTo constrain the model to generate JSON, configure a responseSchema. The model will then respond to any prompt with JSON-formatted output.\n\nPython\nJavaScript\nGo\nREST\nfrom google import genai\nfrom pydantic import BaseModel\n\nclass Recipe(BaseModel):\n    recipe_name: str\n    ingredients: list[str]\n\nclient = genai.Client(api_key=\"GOOGLE_API_KEY\")\nresponse = client.models.generate_content(\n    model=\"gemini-2.0-flash\",\n    contents=\"List a few popular cookie recipes, and include the amounts of ingredients.\",\n    config={\n        \"response_mime_type\": \"application/json\",\n        \"response_schema\": list[Recipe],\n    },\n)\n# Use the response as a JSON string.\nprint(response.text)\n\n# Use instantiated objects.\nmy_recipes: list[Recipe] = response.parsed\n\nNote: Pydantic validators are not yet supported. If a pydantic.ValidationError occurs, it is suppressed, and .parsed may be empty/null.\n\nThe output might look like this:\n\n[\n  {\n    \"recipeName\": \"Chocolate Chip Cookies\",\n    \"ingredients\": [\n      \"1 cup (2 sticks) unsalted butter, softened\",\n      \"3/4 cup granulated sugar\",\n      \"3/4 cup packed brown sugar\",\n      \"1 teaspoon vanilla extract\",\n      \"2 large eggs\",\n      \"2 1/4 cups all-purpose flour\",\n      \"1 teaspoon baking soda\",\n      \"1 teaspoon salt\",\n      \"2 cups chocolate chips\"\n    ]\n  },\n  ...\n]\n\nProviding a schema in a text prompt\n\nInstead of configuring a schema, you can supply a schema as natural language or pseudo-code in a text prompt. This method is not recommended, because it might produce lower quality output, and because the model is not constrained to follow the schema.\n\nWarning: Don't provide a schema in a text prompt if you're configuring a responseSchema. This can produce unexpected or low quality results.\n\nHere's a generic example of a schema provided in a text prompt:\n\nList a few popular cookie recipes, and include the amounts of ingredients.\n\nProduce JSON matching this specification:\n\nRecipe = { \"recipeName\": string, \"ingredients\": array<string> }\nReturn: array<Recipe>\n\n\nSince the model gets the schema from text in the prompt, you might have some flexibility in how you represent the schema. But when you supply a schema inline like this, the model is not actually constrained to return JSON. For a more deterministic, higher quality response, configure a schema on the model, and don't duplicate the schema in the text prompt.\n\nGenerating enum values\n\nIn some cases you might want the model to choose a single option from a list of options. To implement this behavior, you can pass an enum in your schema. You can use an enum option anywhere you could use a string in the responseSchema, because an enum is an array of strings. Like a JSON schema, an enum lets you constrain model output to meet the requirements of your application.\n\nFor example, assume that you're developing an application to classify musical instruments into one of five categories: \"Percussion\", \"String\", \"Woodwind\", \"Brass\", or \"\"Keyboard\"\". You could create an enum to help with this task.\n\nIn the following example, you pass an enum as the responseSchema, constraining the model to choose the most appropriate option.\n\nPython\nfrom google import genai\nimport enum\n\nclass Instrument(enum.Enum):\n  PERCUSSION = \"Percussion\"\n  STRING = \"String\"\n  WOODWIND = \"Woodwind\"\n  BRASS = \"Brass\"\n  KEYBOARD = \"Keyboard\"\n\nclient = genai.Client(api_key=\"GEMINI_API_KEY\")\nresponse = client.models.generate_content(\n    model='gemini-2.0-flash',\n    contents='What type of instrument is an oboe?',\n    config={\n        'response_mime_type': 'text/x.enum',\n        'response_schema': Instrument,\n    },\n)\n\nprint(response.text)\n# Woodwind\n\n\nThe Python library will translate the type declarations for the API. However, the API accepts a subset of the OpenAPI 3.0 schema (Schema).\n\nThere are two other ways to specify an enumeration. You can use a Literal:\n\nPython\nLiteral[\"Percussion\", \"String\", \"Woodwind\", \"Brass\", \"Keyboard\"]\n\n\nAnd you can also pass the schema as JSON:\n\nPython\nfrom google import genai\n\nclient = genai.Client(api_key=\"GEMINI_API_KEY\")\nresponse = client.models.generate_content(\n    model='gemini-2.0-flash',\n    contents='What type of instrument is an oboe?',\n    config={\n        'response_mime_type': 'text/x.enum',\n        'response_schema': {\n            \"type\": \"STRING\",\n            \"enum\": [\"Percussion\", \"String\", \"Woodwind\", \"Brass\", \"Keyboard\"],\n        },\n    },\n)\n\nprint(response.text)\n# Woodwind\n\n\nBeyond basic multiple choice problems, you can use an enum anywhere in a JSON schema. For example, you could ask the model for a list of recipe titles and use a Grade enum to give each title a popularity grade:\n\nPython\nfrom google import genai\n\nimport enum\nfrom pydantic import BaseModel\n\nclass Grade(enum.Enum):\n    A_PLUS = \"a+\"\n    A = \"a\"\n    B = \"b\"\n    C = \"c\"\n    D = \"d\"\n    F = \"f\"\n\nclass Recipe(BaseModel):\n  recipe_name: str\n  rating: Grade\n\nclient = genai.Client(api_key=\"GEMINI_API_KEY\")\nresponse = client.models.generate_content(\n    model='gemini-2.0-flash',\n    contents='List 10 home-baked cookie recipes and give them grades based on tastiness.',\n    config={\n        'response_mime_type': 'application/json',\n        'response_schema': list[Recipe],\n    },\n)\n\nprint(response.text)\n\n\nThe response might look like this:\n\n[\n  {\n    \"recipe_name\": \"Chocolate Chip Cookies\",\n    \"rating\": \"a+\"\n  },\n  {\n    \"recipe_name\": \"Peanut Butter Cookies\",\n    \"rating\": \"a\"\n  },\n  {\n    \"recipe_name\": \"Oatmeal Raisin Cookies\",\n    \"rating\": \"b\"\n  },\n  ...\n]\n\nAbout JSON schemas\n\nConfiguring the model for JSON output using responseSchema parameter relies on Schema object to define its structure. This object represents a select subset of the OpenAPI 3.0 Schema object, and also adds a propertyOrdering field.\n\nTip: On Python, when you use a Pydantic model, you don't need to directly work with Schema objects, as it gets automatically converted to the corresponding JSON schema. To learn more, see JSON schemas in Python.\n\nHere's a pseudo-JSON representation of all the Schema fields:\n\n{\n  \"type\": enum (Type),\n  \"format\": string,\n  \"description\": string,\n  \"nullable\": boolean,\n  \"enum\": [\n    string\n  ],\n  \"maxItems\": integer,\n  \"minItems\": integer,\n  \"properties\": {\n    string: {\n      object (Schema)\n    },\n    ...\n  },\n  \"required\": [\n    string\n  ],\n  \"propertyOrdering\": [\n    string\n  ],\n  \"items\": {\n    object (Schema)\n  }\n}\n\n\nThe Type of the schema must be one of the OpenAPI Data Types, or a union of those types (using anyOf). Only a subset of fields is valid for each Type. The following list maps each Type to a subset of the fields that are valid for that type:\n\nstring -> enum, format, nullable\ninteger -> format, minimum, maximum, enum, nullable\nnumber -> format, minimum, maximum, enum, nullable\nboolean -> nullable\narray -> minItems, maxItems, items, nullable\nobject -> properties, required, propertyOrdering, nullable\n\nHere are some example schemas showing valid type-and-field combinations:\n\n{ \"type\": \"string\", \"enum\": [\"a\", \"b\", \"c\"] }\n\n{ \"type\": \"string\", \"format\": \"date-time\" }\n\n{ \"type\": \"integer\", \"format\": \"int64\" }\n\n{ \"type\": \"number\", \"format\": \"double\" }\n\n{ \"type\": \"boolean\" }\n\n{ \"type\": \"array\", \"minItems\": 3, \"maxItems\": 3, \"items\": { \"type\": ... } }\n\n{ \"type\": \"object\",\n  \"properties\": {\n    \"a\": { \"type\": ... },\n    \"b\": { \"type\": ... },\n    \"c\": { \"type\": ... }\n  },\n  \"nullable\": true,\n  \"required\": [\"c\"],\n  \"propertyOrdering\": [\"c\", \"b\", \"a\"]\n}\n\n\nFor complete documentation of the Schema fields as they're used in the Gemini API, see the Schema reference.\n\nProperty ordering\nWarning: When you're configuring a JSON schema, make sure to set propertyOrdering[], and when you provide examples, make sure that the property ordering in the examples matches the schema.\n\nWhen you're working with JSON schemas in the Gemini API, the order of properties is important. By default, the API orders properties alphabetically and does not preserve the order in which the properties are defined (although the Google Gen AI SDKs may preserve this order). If you're providing examples to the model with a schema configured, and the property ordering of the examples is not consistent with the property ordering of the schema, the output could be rambling or unexpected.\n\nTo ensure a consistent, predictable ordering of properties, you can use the optional propertyOrdering[] field.\n\n\"propertyOrdering\": [\"recipeName\", \"ingredients\"]\n\n\npropertyOrdering[] – not a standard field in the OpenAPI specification – is an array of strings used to determine the order of properties in the response. By specifying the order of properties and then providing examples with properties in that same order, you can potentially improve the quality of results. propertyOrdering is only supported when you manually create types.Schema.\n\nSchemas in Python\n\nWhen you're using the Python library, the value of response_schema must be one of the following:\n\nA type, as you would use in a type annotation (see the Python typing module)\nAn instance of genai.types.Schema\nThe dict equivalent of genai.types.Schema\n\nThe easiest way to define a schema is with a Pydantic type (as shown in the previous example):\n\nPython\nconfig={'response_mime_type': 'application/json',\n        'response_schema': list[Recipe]}\n\n\nWhen you use a Pydantic type, the Python library builds out a JSON schema for you and sends it to the API. For additional examples, see the Python library docs.\n\nThe Python library supports schemas defined with the following types (where AllowedType is any allowed type):\n\nint\nfloat\nbool\nstr\nlist[AllowedType]\nAllowedType|AllowedType|...\nFor structured types:\ndict[str, AllowedType]. This annotation declares all dict values to be the same type, but doesn't specify what keys should be included.\nUser-defined Pydantic models. This approach lets you specify the key names and define different types for the values associated with each of the keys, including nested structures.\nBest practices\n\nKeep the following considerations and best practices in mind when you're using a response schema:\n\nThe size of your response schema counts towards the input token limit.\nBy default, fields are optional, meaning the model can populate the fields or skip them. You can set fields as required to force the model to provide a value. If there's insufficient context in the associated input prompt, the model generates responses mainly based on the data it was trained on.\n\nA complex schema can result in an InvalidArgument: 400 error. Complexity might come from long property names, long array length limits, enums with many values, objects with lots of optional properties, or a combination of these factors.\n\nIf you get this error with a valid schema, make one or more of the following changes to resolve the error:\n\nShorten property names or enum names.\nFlatten nested arrays.\nReduce the number of properties with constraints, such as numbers with minimum and maximum limits.\nReduce the number of properties with complex constraints, such as properties with complex formats like date-time.\nReduce the number of optional properties.\nReduce the number of valid values for enums.\n\nIf you aren't seeing the results you expect, add more context to your input prompts or revise your response schema. For example, review the model's response without structured output to see how the model responds. You can then update your response schema so that it better fits the model's output.\n\nWhat's next\n\nNow that you've learned how to generate structured output, you might want to try using Gemini API tools:\n\nFunction calling\nCode execution\nGrounding with Google Search\nSend feedback\n\nExcept as otherwise noted, the content of this page is licensed under the Creative Commons Attribution 4.0 License, and code samples are licensed under the Apache 2.0 License. For details, see the Google Developers Site Policies. Java is a registered trademark of Oracle and/or its affiliates.\n\nLast updated 2025-05-12 UTC.\n\nTerms\nPrivacy",
  "updatedAt": "2025-05-13T03:13:38.491Z"
}